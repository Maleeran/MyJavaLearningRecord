# Day27: 多线程基础

---

## 学习目标
1. **理解多线程基础**：掌握线程的概念，为什么需要多线程，以及 Java 中的线程模型。
2. **熟练创建线程**：学会两种方式——继承 `Thread` 类和实现 `Runnable` 接口，理解它们的区别。
3. **掌握线程生命周期**：熟悉线程的 5 个状态（新建、就绪、运行、阻塞、终止），知道如何管理线程状态。
4. **实践应用**：通过一个多线程文件下载模拟项目，结合 Day26 的 IO 流，实现并发任务。
5. **异常处理**：结合 Day22-23，处理线程中的异常和中断。

---
## 学习笔记

### 1. 多线程基础（为什么需要多线程？）
想象单线程像一个人做饭：洗菜、切菜、炒菜，一个一个来。如果切菜卡住了（比如等水烧开），整个过程停滞。多线程像多个厨师分工：一个人洗菜，另一个人切菜，同时进行，提高效率。

- **线程概念**：线程是程序执行的最小单位，一个进程（如 Java 程序）可有多个线程。Java 默认主线程（main 方法）。
- **多线程优势**：
    - **并发**：同时处理多个任务（如下载文件时还能响应用户输入）。
    - **效率**：利用 CPU 多核，加速计算密集任务。
    - **响应性**：UI 程序中，主线程处理界面，子线程处理后台任务。
- **缺点**：线程切换有开销，需处理同步问题（Day28 会学）。
- **Java 线程模型**：Java 用 `Thread` 类表示线程，基于 OS 线程。

### 2. 创建线程的两种方式（详细对比）
Java 提供两种创建线程的方式，就像两种做饭方式：一种是直接雇厨师（继承 Thread），另一种是雇助手（实现 Runnable）。

- **继承 Thread 类**：
    - 步骤：定义类继承 `Thread`，重写 `run()` 方法（线程执行体），创建对象调用 `start()` 启动。
    - 通俗：`run()` 是“菜谱”，`start()` 是“开火”。
    - 示例：`class MyThread extends Thread { public void run() { System.out.println("Running"); } }`；`MyThread t = new MyThread(); t.start();`。
    - 优点：简单，直接用 `this` 访问线程属性。
    - 缺点：Java 单继承，无法继承其他类。

- **实现 Runnable 接口**：
    - 步骤：定义类实现 `Runnable`，实现 `run()` 方法；创建 `Thread` 对象传入 Runnable 实例，调用 `start()`。
    - 通俗：Runnable 是“菜谱接口”，Thread 是“厨师”执行菜谱。
    - 示例：`class MyRunnable implements Runnable { public void run() { System.out.println("Running"); } }`；`Thread t = new Thread(new MyRunnable()); t.start();`。
    - 优点：可继承其他类，灵活；多个线程共享 Runnable 对象。
    - 缺点：需额外创建 Thread 对象。

- **区别**：
    - 继承 Thread：类本身是线程，适合简单任务。
    - 实现 Runnable：接口方式，适合复杂类或共享数据。
    - 优先用 Runnable（Java 官方推荐），因为接口灵活。
- **常见方法**：
    - `start()`：启动线程，调用 run()。
    - `run()`：线程体，不要直接调用（会当普通方法执行）。
    - `sleep(long millis)`：暂停线程（静态方法）。
    - `getName()`、`setName()`：线程名称。
    - `getState()`：获取线程状态。

### 3. 线程生命周期（5 个状态，像人的一生）
线程生命周期像人的一生：出生、上学、工作、休息、去世。Java 线程有 5 个状态（用 `Thread.State` 枚举表示）：

- **新建（NEW）**：创建线程对象，但未调用 `start()`。像婴儿出生，还没上学。
    - 示例：`Thread t = new Thread();`。

- **就绪（RUNNABLE）**：调用 `start()` 后，线程等待 CPU 调度。像上学准备好，但等老师点名。
    - 可运行，但不一定在运行（取决于 OS 调度）。

- **运行（RUNNING）**：线程获得 CPU 执行 `run()`。像上课中，积极发言。
    - 这是就绪状态的子状态（Java API 中 RUNNABLE 包括就绪和运行）。

- **阻塞（BLOCKED/TIMED_WAITING/WAITING）**：线程暂停执行，等待资源。
    - **BLOCKED**：等待锁（Day28 同步）。
    - **TIMED_WAITING**：`sleep()` 或 `join(timeout)`，有时间限制。
    - **WAITING**：`join()` 或 `wait()`，无限等待。
    - 通俗：像休息或等别人（阻塞是“卡住”）。

- **终止（TERMINATED）**：`run()` 执行完或异常终止。像毕业或退休，无法复活。
    - 示例：线程正常结束或抛出未捕获异常。

- **状态转换**：
    - 新建 -> start() -> 就绪 -> CPU 调度 -> 运行。
    - 运行 -> sleep()/wait() -> 阻塞 -> 唤醒 -> 就绪。
    - 运行 -> 结束 -> 终止。
- **查询状态**：`thread.getState()`，调试时用。

- **中断**：`interrupt()` 发送中断信号，线程可检查 `isInterrupted()` 处理。像“叫醒”睡觉的线程。

### 4. 应用场景和注意事项
- **场景**：下载文件（多线程分段下载）、服务器处理请求（每个请求一个线程）。
- **与 Day26 衔接**：IO 流在多线程中需小心同步（Day28），避免并发读写文件。
- **常见问题**：线程安全（共享数据冲突）、死锁（互相等待）。先学基础，日后深入。
- **最佳实践**：用 Runnable；用 try-catch 处理 run() 异常；避免直接调用 run()。

---

## 练习题
1. **基础题**：
    - 用继承 Thread 创建一个线程，打印 "Hello from thread!" 10 次。
    - 用实现 Runnable 创建线程，计算 1 到 1000 的和，并在 main 线程中等待它结束（用 join()）。

2. **进阶题**：
    - 修改 `FileDownloaderThread`，添加 sleep() 模拟下载延迟，观察线程生命周期（用 getState() 打印状态）。
    - 实现一个计数器线程，用 Runnable 共享计数器变量，运行两个线程同时递增，观察结果（引入同步问题预习）。

3. **项目题**：
    - 扩展项目，用 3 个线程分段下载文件，整合 Day26 的 IO 流。
    - 创建一个多线程日志记录器，用字符流写入日志文件，每个线程记录自己的执行时间。

4. **LeetCode 练习**：
    - **LeetCode 1114**：Print in Order（用线程控制打印顺序）。
    - **LeetCode 1195**：Fizz Buzz Multithreaded（多线程打印 Fizz Buzz）。

---
