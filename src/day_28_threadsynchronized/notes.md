# Day28: 线程同步与锁机制

---

## 学习目标
1. **理解线程同步**：掌握为什么需要同步，线程安全的概念，以及如何避免并发问题。
2. **熟练使用 synchronized**：学会 synchronized 关键字在方法和代码块上的应用，实现线程安全。
3. **掌握锁机制**：了解 ReentrantLock 等高级锁，比较与 synchronized 的差异。
4. **识别和解决死锁**：理解死锁原因，学会预防和解决策略。
5. **实践应用**：通过一个多线程银行转账项目，结合 Day27 的线程创建，实现安全并发操作。

---

## 学习笔记

### 1. 线程安全和同步基础（为什么需要同步？）
想象多线程像多人同时用一个银行账户转钱：如果两人同时查余额 1000，转出 600，每个都以为够用，结果余额变 -200（负值）。这就是“线程不安全”——共享资源被并发修改导致错误。

- **线程安全**：多个线程访问共享数据时，结果正确、一致。像“原子操作”——要么全做，要么不做。
- **为什么需要同步**？多线程并发时，线程切换（CPU 时间片）可能在操作中间发生，导致数据混乱。同步是“加锁”，确保关键代码一次只一个线程执行。
- **共享资源**：全局变量、静态变量、文件等。
- **Java 同步机制**：用锁（Monitor）控制访问。每个对象都有一个内置锁。

### 2. synchronized 关键字详解（简单锁机制）
synchronized 是 Java 的内置锁，像“房间门锁”——线程进入时锁门，出来时开门。

- **synchronized 方法**：
    - 语法：`public synchronized void method() { ... }`
    - 通俗：方法前加 synchronized，锁是 this 对象（实例方法）或 Class 对象（静态方法）。
    - 示例：`transfer()` 方法，确保转账时独占账户。
    - 优点：简单，自动获取/释放锁。
    - 缺点：锁粒度大（整个方法），效率低。

- **synchronized 块**：
    - 语法：`synchronized (obj) { ... }` // obj 是锁对象
    - 通俗：只锁关键代码块，灵活。锁对象可自定义（如 private Object lock = new Object();）。
    - 示例：`transferWithBlock()` 中锁 this。
    - 优点：细粒度锁，减少等待时间。
    - 缺点：需手动选择锁对象，避免死锁。

- **工作原理**：
    - 线程进入 synchronized 代码时，尝试获取锁（monitorenter）。
    - 获取成功：执行代码。
    - 获取失败：进入阻塞队列等待（BLOCKED 状态）。
    - 执行完：释放锁（monitorexit），唤醒等待线程。
- **可重入锁**：同一个线程可多次获取同一锁（如递归方法），不会死锁。
- **与 Day27 衔接**：多线程创建后，用 synchronized 保护共享数据，避免 Day27 计数器问题的“数据竞争”。

### 3. 锁机制进阶（ReentrantLock 等）
synchronized 是隐式锁，ReentrantLock 是显式锁，像“智能门锁”——更灵活。

- **ReentrantLock**：
    - 语法：`private final ReentrantLock lock = new ReentrantLock();`；`lock.lock(); try { ... } finally { lock.unlock(); }`
    - 通俗：手动加锁/解锁，支持公平锁（先来先得）和超时获取。
    - 优点：比 synchronized 灵活，可中断、可超时。
    - 缺点：需手动 unlock()，finally 块必备。
- **其他锁**：`ReadWriteLock`（读写分离，读共享写独占），适合读多写少场景。
- **选择**：简单用 synchronized，复杂用 ReentrantLock。

### 4. 死锁详解（原因和解决）
死锁像两人互相握手等对方先放（循环等待），线程卡住无法前进。

- **死锁条件**（4 个必要条件，像死锁的“4 要素”）：
    - **互斥**：资源一次只一个线程用（锁本身）。
    - **占有并等待**：线程持有锁 A 等锁 B。
    - **不可抢占**：锁不能被强行夺取。
    - **循环等待**：线程 1 等线程 2 的锁，线程 2 等线程 1 的锁。
- **示例**：线程 1 锁 A 再锁 B，线程 2 锁 B 再锁 A，可能卡住。
- **解决策略**：
    - **避免循环**：统一锁顺序（如总是先锁 A 后锁 B）。
    - **银行家算法**：预分配资源（复杂，不常用）。
    - **超时获取**：用 ReentrantLock 的 `tryLock(timeout)`，超时放弃。
    - **检测工具**：用 jstack 或 IDE 线程视图检查死锁。
    - **最小化锁范围**：锁块短小，减少持有时间。
- **预防**：设计时避免嵌套锁；用 `synchronized` 时小心对象顺序。

### 5. 应用场景和注意事项
- **场景**：银行转账（同步余额）、库存扣减（电商）、日志写入（多线程写文件）。
- **与 Day26 衔接**：IO 流如文件写在多线程中需同步（用 synchronized 块锁文件对象）。
- **线程安全类**：Java 提供如 `AtomicInteger`（原子操作）、`ConcurrentHashMap`（并发集合）。
- **最佳实践**：锁粒度最小；避免死锁；测试多线程场景。
- **调试**：用 Thread.sleep() 模拟延迟，暴露问题；用 jvisualvm 或 IDE 监控线程。

---

## 练习题
1. **基础题**：
    - 用 synchronized 方法实现一个线程安全的计数器，两个线程同时递增 1000 次，确保最终值为 2000。
    - 用 synchronized 块实现一个共享列表，多个线程添加元素，避免并发修改异常。

2. **进阶题**：
    - 修改银行项目，用 ReentrantLock 替换 synchronized，添加 tryLock() 防止死锁。
    - 故意制造死锁场景（两个线程互锁），然后用锁顺序解决。

3. **项目题**：
    - 扩展银行项目，添加“存款”方法，用 ReadWriteLock 支持并发读余额。
    - 整合 Day26 IO 流，用多线程同步写日志文件，避免并发写混乱。

4. **LeetCode 练习**：
    - **LeetCode 1115**：Print FooBar Alternately（用 synchronized 控制交替打印）。
    - **LeetCode 1226**：The Dining Philosophers（模拟死锁和解决）。
